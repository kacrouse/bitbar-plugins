#!/usr/bin/env /usr/local/bin/node

/** 
 * This file was generated by rollup.js, while an attempt has been made to make 
 * it readable, it will likely be easier to understand by viewing the source
 * at https://github.com/kacrouse/xbar-plugin-open-sf-org#readme.
 * 
 * <xbar.title>Open Salesforce Org</xbar.title>
 * <xbar.version>1.0.0</xbar.version>
 * <xbar.author>Kyle Crouse</xbar.author>
 * <xbar.author.github>kacrouse</xbar.author.github>
 * <xbar.desc>Open any Salesforce Org registered with the Salesforce CLI.</xbar.desc>
 * <xbar.image>https://github.com/kacrouse/xbar-plugin-open-sf-org/blob/master/assets/screenshot.png?raw=true</xbar.image>
 * <xbar.dependencies>node,sfdx</xbar.dependencies>
 * <xbar.abouturl>https://github.com/kacrouse/xbar-plugin-open-sf-org#readme</xbar.abouturl>
 * 
 * The page an org opens to can be configured through a `.bitbarrc` file in your home directory.
 * To set the page for all orgs, add the following to the file:
 * 
 * [open_salesforce_org]
 * DEFAULT_PATH=/path/to/open/to
 * 
 * 
 * To set the page for individual orgs, add an `open_salesforce_org.paths` 
 * section, with a line for each org. Orgs can be specified by alias or 
 * username.
 * 
 * [open_salesforce_org.paths]
 * myOrg@example.com=/path/to/open/to
 * myOtherOrgAlias=/other/path/to/open/to
 * 
 * 
 * The most specific configuration takes precedence, so if `DEFAULT_PATH` is set 
 * along with a value for an individual org, the value for the individual org 
 * will be used.
 */
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = _interopDefault(require('path'));
var child_process = require('child_process');
var fs = _interopDefault(require('fs'));

/**********************************
 *  node_modules/bitbar/index.js  *
 **********************************/

const separator = Symbol('separator');

const encodeHref = url => {
  url = encodeURI(url);
  url = url.replace(/'/g, '%27');
  url = url.replace(/&/g, '%26');
  return url;
};

const create = (input, options = {}, menuLevel = 0) => {
  if (typeof options.text !== 'undefined') {
    throw new TypeError('The `text` option is not supported as a top-level option. Use it on an item instead.');
  }

  return input.map(line => {
    if (typeof line === 'string') {
      line = {
        text: line
      };
    }

    if (line === separator) {
      return '--'.repeat(menuLevel) + '---';
    }

    line = { ...options,
      ...line
    };
    const {
      text
    } = line;

    if (typeof text !== 'string') {
      throw new TypeError('The `text` property is required and should be a string');
    }

    delete line.text;
    let submenuText = '';

    if (typeof line.submenu === 'object' && line.submenu.length > 0) {
      submenuText = `\n${create(line.submenu, options, menuLevel + 1)}`;
      delete line.submenu;
    }

    const prefix = '--'.repeat(menuLevel);
    return text.split('\n').map(textLine => {
      const options = Object.keys(line).map(key => {
        const value = key === 'href' ? encodeHref(line[key]) : line[key];
        return `${key}="${value}"`;
      }).join(' ');
      return `${prefix}${textLine}|${options}`;
    }).join('\n').concat(submenuText);
  }).join('\n');
};

var bitbar = (input, options) => {
  console.log(create(input, options));
};

var separator_1 = separator;
var darkMode = process.env.BitBarDarkMode === '1';
var create_1 = create;
bitbar.separator = separator_1;
bitbar.darkMode = darkMode;
bitbar.create = create_1;

/*****************
 *  src/util.js  *
 *****************/

const simpleCache = (getValue, cache = {}) => key => {
  let result = cache[key];

  if (!result) {
    result = getValue(key);
    cache[key] = result;
  }

  return result;
};

const findExecutable = simpleCache(name => child_process.spawnSync(`which ${name}`, [], {
  shell: true,
  env: { ...process.env,
    PATH: [path.resolve("/usr/local/bin"), process.env.PATH].join(":")
  }
}).stdout?.toString().trim());

const runCommand = command => child_process.spawnSync(command, [], {
  shell: true
}).stdout?.toString();

const sortBy = (items, identity) => {
  return items.sort((value, other) => {
    const valueId = identity(value);
    const otherId = identity(other);

    if (valueId > otherId) {
      return 1;
    }

    if (valueId < otherId) {
      return -1;
    }

    return 0;
  });
};

/***********************
 *  src/salesforce.js  *
 ***********************/

const getOrgs = () => {
  const orgListOutput = JSON.parse(runCommand(`${findExecutable("sfdx")} force:org:list --json`));

  if (orgListOutput.status && orgListOutput.status !== 0) {
    throw Error("Error getting orgs through the Salesforce CLI. " + JSON.stringify(orgListOutput.result));
  }

  return [...orgListOutput.result.nonScratchOrgs, ...orgListOutput.result.scratchOrgs];
};

/************************
 *  commonjsHelpers.js  *
 ************************/

function createCommonjsModule(fn, basedir, module) {
	return module = {
	  path: basedir,
	  exports: {},
	  require: function (path, base) {
      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    }
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

/*****************************
 *  node_modules/ini/ini.js  *
 *****************************/
var ini = createCommonjsModule(function (module, exports) {
  exports.parse = exports.decode = decode;
  exports.stringify = exports.encode = encode;
  exports.safe = safe;
  exports.unsafe = unsafe;
  var eol = typeof process !== 'undefined' && process.platform === 'win32' ? '\r\n' : '\n';

  function encode(obj, opt) {
    var children = [];
    var out = '';

    if (typeof opt === 'string') {
      opt = {
        section: opt,
        whitespace: false
      };
    } else {
      opt = opt || {};
      opt.whitespace = opt.whitespace === true;
    }

    var separator = opt.whitespace ? ' = ' : '=';
    Object.keys(obj).forEach(function (k, _, __) {
      var val = obj[k];

      if (val && Array.isArray(val)) {
        val.forEach(function (item) {
          out += safe(k + '[]') + separator + safe(item) + '\n';
        });
      } else if (val && typeof val === 'object') children.push(k);else out += safe(k) + separator + safe(val) + eol;
    });
    if (opt.section && out.length) out = '[' + safe(opt.section) + ']' + eol + out;
    children.forEach(function (k, _, __) {
      var nk = dotSplit(k).join('\\.');
      var section = (opt.section ? opt.section + '.' : '') + nk;
      var child = encode(obj[k], {
        section: section,
        whitespace: opt.whitespace
      });
      if (out.length && child.length) out += eol;
      out += child;
    });
    return out;
  }

  function dotSplit(str) {
    return str.replace(/\1/g, '\u0002LITERAL\\1LITERAL\u0002').replace(/\\\./g, '\u0001').split(/\./).map(function (part) {
      return part.replace(/\1/g, '\\.').replace(/\2LITERAL\\1LITERAL\2/g, '\u0001');
    });
  }

  function decode(str) {
    var out = {};
    var p = out;
    var section = null; //          section     |key      = value

    var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
    var lines = str.split(/[\r\n]+/g);
    lines.forEach(function (line, _, __) {
      if (!line || line.match(/^\s*[;#]/)) return;
      var match = line.match(re);
      if (!match) return;

      if (match[1] !== undefined) {
        section = unsafe(match[1]);

        if (section === '__proto__') {
          // not allowed
          // keep parsing the section, but don't attach it.
          p = {};
          return;
        }

        p = out[section] = out[section] || {};
        return;
      }

      var key = unsafe(match[2]);
      if (key === '__proto__') return;
      var value = match[3] ? unsafe(match[4]) : true;

      switch (value) {
        case 'true':
        case 'false':
        case 'null':
          value = JSON.parse(value);
      } // Convert keys with '[]' suffix to an array


      if (key.length > 2 && key.slice(-2) === '[]') {
        key = key.substring(0, key.length - 2);
        if (key === '__proto__') return;
        if (!p[key]) p[key] = [];else if (!Array.isArray(p[key])) p[key] = [p[key]];
      } // safeguard against resetting a previously defined
      // array by accidentally forgetting the brackets


      if (Array.isArray(p[key])) p[key].push(value);else p[key] = value;
    }); // {a:{y:1},"a.b":{x:2}} --> {a:{y:1,b:{x:2}}}
    // use a filter to return the keys that have to be deleted.

    Object.keys(out).filter(function (k, _, __) {
      if (!out[k] || typeof out[k] !== 'object' || Array.isArray(out[k])) return false; // see if the parent section is also an object.
      // if so, add it to that, and mark this one for deletion

      var parts = dotSplit(k);
      var p = out;
      var l = parts.pop();
      var nl = l.replace(/\\\./g, '.');
      parts.forEach(function (part, _, __) {
        if (part === '__proto__') return;
        if (!p[part] || typeof p[part] !== 'object') p[part] = {};
        p = p[part];
      });
      if (p === out && nl === l) return false;
      p[nl] = out[k];
      return true;
    }).forEach(function (del, _, __) {
      delete out[del];
    });
    return out;
  }

  function isQuoted(val) {
    return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
  }

  function safe(val) {
    return typeof val !== 'string' || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, '\\;').replace(/#/g, '\\#');
  }

  function unsafe(val, doUnesc) {
    val = (val || '').trim();

    if (isQuoted(val)) {
      // remove the single quotes before calling JSON.parse
      if (val.charAt(0) === "'") val = val.substr(1, val.length - 2);

      try {
        val = JSON.parse(val);
      } catch (_) {}
    } else {
      // walk the val to find the first not-escaped ; character
      var esc = false;
      var unesc = '';

      for (var i = 0, l = val.length; i < l; i++) {
        var c = val.charAt(i);

        if (esc) {
          if ('\\;#'.indexOf(c) !== -1) unesc += c;else unesc += '\\' + c;
          esc = false;
        } else if (';#'.indexOf(c) !== -1) break;else if (c === '\\') esc = true;else unesc += c;
      }

      if (esc) unesc += '\\';
      return unesc.trim();
    }

    return val;
  }
});
var ini_1 = ini.parse;
var ini_2 = ini.decode;
var ini_3 = ini.stringify;
var ini_4 = ini.encode;
var ini_5 = ini.safe;
var ini_6 = ini.unsafe;

/*******************
 *  src/config.js  *
 *******************/

const loadConfig = (homePath, defaultConfig) => {
  const configPath = path.resolve(homePath, ".bitbarrc");

  try {
    fs.accessSync(configPath, fs.constants.R_OK);
  } catch (e) {
    return defaultConfig;
  }

  let config;

  try {
    config = ini_1(fs.readFileSync(configPath, {
      encoding: "utf8"
    }));
  } catch (e) {
    console.error(`Error reading .bitbarrc: ${e.message || "Unknown error"}`);
  }

  return { ...defaultConfig,
    ...config.open_salesforce_org
  };
};

/******************
 *  src/index.js  *
 ******************/
const templateImage = "iVBORw0KGgoAAAANSUhEUgAAACUAAAAaCAQAAACau13wAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAFiUAABYlAUlSJPAAAAAHdElNRQflBR8ADgzd8omNAAAAEGNhTnYAAABHAAAALgAAABIAAAAAw9stjAAAAZtJREFUOMut1D9oE3EYxvFP7mqL1r8gFGtxKw6itEO7iBQEFwsqFMHNyUUKKnVRFBScRAcHZwcVcTIUXJ1soeCkSEGpDlYbxCZS0VhNeg6XmlQueOnlfeA4fj/ue8/73Hs/6tXpuCcWLFvywmV9tfXAHgcd0q9Tqtrpjq+iv6qaNoID7ppVVPLOI4fl/gfa6n4DZlVzrnm7ZmXReR3JiNV3XHBLkMr9D+OmDNot56OX3qg0bvd6leCpmb6YV6mF8Mk9A42oUcstoP7Ve2N11LkMoEik4IhaPl3pPnLT6nFdb4wqiDLChp0Ka7cnbcqECmwO0G1Md0ZX7KPDDdWMsUcivzmm1AZQ5FvgjO2Zm4O5wHBbQJGnlNvS3qy98Uxl1XenIZ8ZtORifPAcVcyA+em5E/HvlxO64qqwpZCrJhWF5s2YVqxvbHTJQkteHicNUK52HTBqvw36DCX6KKvYAgoeuulzM1RcoRVDJvUkoG7LG7RNwYzXVtLlMJFwoj6zaz1z22Vizaz9kte/HlDc9IgHPigrmXLWjnSP/QEun6abl+XrlgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0wNS0zMVQwMDoxNDoxMiswMDowMEucK5AAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMDUtMzFUMDA6MTQ6MTIrMDA6MDA6wZMsAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAABJRU5ErkJggg==";
const sfdx = findExecutable("sfdx");

if (!sfdx) {
  console.error("Unable to find sfdx executable.");
  process.exit(1);
}

let orgs = [];

try {
  orgs = getOrgs();
} catch (e) {
  console.error(e.message);
  process.exit(1);
}

const {
  DEFAULT_PATH,
  paths
} = loadConfig(process.env.HOME, {
  DEFAULT_PATH: "/",
  paths: {}
});
bitbar([{
  templateImage,
  text: ""
}, bitbar.separator, ...(orgs.length > 0 ? sortBy(orgs, o => (o.alias || o.username).toLowerCase()).map(({
  alias,
  username
}) => ({
  text: alias || username,
  bash: sfdx,
  param1: "force:org:open",
  param2: "--targetusername",
  param3: username,
  param4: "--path",
  param5: paths[alias] || paths[username] || DEFAULT_PATH,
  terminal: false
})) : ["No orgs found. To see orgs here, create or authenticate one with the Salesforce CLI."])]);
